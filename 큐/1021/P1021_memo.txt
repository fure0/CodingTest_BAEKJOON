회전하는 큐

[입력]
첫째 줄에 큐의 크기 N과 뽑아내려고 하는 수의 개수 M이 주어진다. 
N은 50보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다. 
둘째 줄에는 지민이가 뽑아내려고 하는 수의 위치가 순서대로 주어진다. 위치는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.

[출력]
첫째 줄에 문제의 정답을 출력한다.

[접근]
@@@ deque의 경우 주의 @@@
offer 뒤쪽에 추가
push 앞쪽에 추가

변수
LinkedList<Integer> deque = new LinkedList<Integer>();
int N // 큐의 크기(1 ~ N)
int M // 뽑으려는 숫자의 개수

// 1부터 N까지 덱에 담아둔다.

int[] seq = new int[M];	// 뽑고자 하는 수를 담은 배열

for(int i = 0; i < M; i++) {
    // 덱에서 뽑고자 하는 숫자의 위치(index) 찾기 
    int target_idx
    int half_idx;
    half_idx = deque.size() / 2; 
    //만약 현재 덱의 원소가 짝수 개라면 현재 덱의 절반 크기에서 -1 감소시킨다. 

    // 중간 지점 또는 중간 지점보다 원소의 위치가 앞에 있을 경우
    // idx 보다 앞에 있는 원소들을 모두 뒤로 보낸다. (2번 연산)

    // 중간 지점보다 원소의 위치가 뒤에 있는 경우 
    // idx를 포함한 뒤에 있는 원소들을 모두 앞으로 보낸다. (3번 연산)

    // 연산이 끝나면 맨 앞 원소를 삭제

출력


[힌트]

Deque = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

뽑을 숫자 : 2, 9, 5

count : 2번과 3번연산 누적 횟수 

과정 1-1 : 2는 현재 덱에서 중앙 보다 앞에 존재하기 때문에 2를 뽑기 위해 2번 연산(앞에 있는 수를 뒤로 보냄)을 한 번 실행

<Result> 

Deque = {2, 3, 4, 5, 6, 7, 8, 9, 10, 1}

count = 1

과정 1-2 : 2를 뽑음.

<Result> 

Deque = {3, 4, 5, 6, 7, 8, 9, 10, 1}

count = 1

과정 2-1 : 9는 현재 덱에서 중앙 보다 뒤에 있기 때문에 9를 뽑기 위해 3번 연산(뒤에 있는 수를 앞으로 보냄)을 세 번 실행

<Result> 

Deque = {9, 10, 1, 3, 4, 5, 6, 7, 8}

count = 4

 

과정 1-2 : 9를 뽑음.

<Result> 

Deque = {10, 1, 3, 4, 5, 6, 7, 8}

count = 4
 
과정 3-1 : 5는 현재 덱에서 뒤에 있기 때문에 5를 뽑기 위해 3번 연산(뒤에 있는 수를 앞으로 보냄)을 네 번 실행

(물론 2번연산을 네 번 실행해도 된다. 다만 가독성을 위해 3번 연산을 하기로 한다.)

<Result> 

Deque =  {5, 6, 7, 8, 10, 1, 3, 4}

count = 8

과정 1-2 : 5를 뽑음.

<Result> 

Deque = {6, 7, 8, 10, 1, 3, 4}

count = 8

결과 : 8